=head1 NAME

PEF::Log - Logging framework for Perl

=head1 SYNOPSIS

   use PEF::Log;
   PEF::Log->init(file => "log-config.yaml");
   
   logit debug {"started program"};
   
   --or--
   
   use PEF::Log (sublevels => [qw(start input output flesh)];
   PEF::Log->init(file => "log-config.yaml");
   
   logit debug::start {"started program"} info::start {"everything is ok"};
   # ... some stuff
   logit debug::output { { result => "OK" } };
   
   --or--
   
   use PEF::Log;
   PEF::Log->init(plain_config => <<CONFIG);
   ---
   appenders:
     screen:
       out: stderr
       format: line
     file-debug:
       class: file
       out: ./debug.txt
       format: line
   formats:
     line:
       format: "%d [%P][%l.%s][%C{1}::%S(%L)]: %m%n"
       stringify: dumpAll
       class: pattern
   routes:
     default:
       debug: file-debug
       info: file-debug
       warning: [file-debug, screen]
       error: [file-debug, screen]
       critical: [file-debug, screen]
       fatal: [file-debug, screen]
       deadly: [file-debug, screen]
     context:
       "secret stuff":
         debug: off
   CONFIG
   {
     my $ctx = "secret stuff";
     logcontext \$ctx;
     # try now debug
     logit debug {"nobody see it"};
   }
   logit debug {"now it magically appears in file-debug"};

=head1 ABSTRACT

PEF::Log provides a very powerful logging API for your application

=head1 DESCRIPTION

PEF::Log makes logging easy and intuitive. It combines performance and very 
fine-grained logging behavior of your application.

=over 4

=item *

Logging messages are lazy calculated because they are inside anonymous code 
reference which is good for performance. 

=item *

It has an automatic context stack management with localized cache. 

=item *

Message routing can depend on context, subroutine or package.  

=item *

Logging levels can possess sublevels for precise control of logging behavior
of different application parts.  

=item *

Logging messages can be simple strings, anonymous arrays or hashes.

=item *

It is possible to inject transformation filters for some log appenders.

=item *
 
Logger's config can be reloaded at any time.

=back

=head1 How to use it

First, it must be initialized in your application startup code.

   use PEF::Log;
   PEF::Log->init(file => "log-config.yaml");

To use sublevels, they must be passed as import arguments to PEF::Log:

   use PEF::Log (sublevels => [qw(start input output flesh)];
   PEF::Log->init(file => "log-config.yaml");

Config file must be in YAML format. You can also use C<plain_config> parameter
to pass config as plain text in YAML format. Don't intermix C<plain_config> 
and C<file> options, they are known to be not merging properly.

Second, just use it.

   logit info {"started program"};

C<logit> is exported by default logging function. It accepts messages after 
passing them through one of the B<level-functions>, such as: C<debug>,
C<info>, C<warning>, C<error>, C<critical>, C<fatal> and C<deadly>, which are
also exported. C<deadly> means "log and die". It flushes open appenders and dies.

With defined sublevels every of B<level-functions> is multiplicated by every 
sublevel, e.g.: C<debug::start>, C<debug::input>, C<debug::output>, 
C<debug::flesh>, and so on.

B<Level-functions> accepts code block as it first argument. Code blocks are 
executed only when this particular log level finds its appender. Its returned 
values are used as logging messages. Every value - one message. 
B<Level-functions> passes all others arguments unchanged.  Therefore it is 
possible to log different levels in one go:

   logit debug::start {"started program"} info::start {"everything is ok"};

One of the interesting features is using structured messages to log:

   logit debug::input { {email => $email, password => $password, ip => $ip } };

This anonymous hash is passed to appropriate appenders as is. Line-oriented
appenders can transform such message into string using B<pattern> formatter.

   formats:
     line:
       format: "%d $m{ip} - %m{email}%n"
       stringify: dumpAll
       class: pattern

Every appender that is configured to use format C<line> here will write line
such as "15.04.10 16:36:21 192.168.1.1 - test@test.net\n" in its output.

=head1 How to use context

Context is just a stack of named local storages. Living time of susch a storage
is the same as lexical scope of the binded variable. There's always context
"main" on the lowest level:

   logcache X => "X-Men";      # put "X-Men" in key "X" of the context storage
   {                           # start new scope
     my $ctx = "second level"; # binded variable
     logcontext \$ctx;         # binded variable must be passed always by reference
     logcache X => "X-Women";  # now key "X" is equal to "X-Women"
     print logcache "X";       # prints "X-Women"
   }                           # end of the scope of $ctx
   print logcache "X";         # prints "X-Men"

=cut